#+TITLE: FPOO in Elixir
#+OPTIONS: num:nil ^:nil toc:nil

* Setup

Let's define a module to keep exercises in.

#+name: exercises_module
#+BEGIN_SRC elixir :tangle lib/fp_oo_elx/exercises.ex :noweb yes
  defmodule FpOoElx.Exercises do
    <<exercises>>
  end
#+END_SRC

And a module to keep tests in.

#+name: tests_module
#+BEGIN_SRC elixir :tangle test/exercises_test.exs :noweb yes
  defmodule ExercisesTest do
    use ExUnit.Case
    import FpOoElx.Exercises
    <<tests>>
    doctest FpOoElx.Exercises
  end
#+END_SRC

* Re-implementing apply in Elixir                               :fpoo:elixir:
   :PROPERTIES:
   :ID:       o2b:6e62c054-5535-4cd8-8b37-51b176ad4585
   :POST_DATE: [2013-11-18 Mon 09:00]
   :POSTID:   7849
   :BLOG:     virtuouscode
   :CATEGORY: Elixir
   :END:

[boilerplate bypath="fp-oo"]

Elixir already has a perfectly good [[http://elixir-lang.org/docs/stable/Kernel.html#apply/2][=apply=]]. But [[https://leanpub.com/fp-oo][FPOO]] suggests I try
to write my own version, and why not?

#+name: exercises
#+BEGIN_SRC elixir
  def my_apply(func, sequence) do
    code = quote do
      unquote(func).(unquote_splicing(sequence))
    end
    {result, _} = Code.eval_quoted(code)
    result
  end
#+END_SRC

This is considerably more verbose than the Clojure example in the
book, without really seeming to add much expressiveness:

#+BEGIN_SRC clj
  (def my-apply
    (fn [function sequence]
      (eval (cons function sequence))))
#+END_SRC

Perhaps an Elixir-experienced reader can show me a more idiomatic
form. Although I think Elixir metaprogramming is likely always going
to be wordier than Lisp because of a) its less-concise
quoting/unquoting constructs; and b) the fact that the sexp-ish things
that Elixir macros work on under the covers are more complex than
their lisp counterparts. As an example, here's the code-as-data
version of adding two integers:

#+BEGIN_SRC elixir
quote do: 1 + 2
# => {:+, [context: Elixir, import: Kernel], [1, 2]}
#+END_SRC

Whereas the lisp code-as-data representation of =(+ 1 2)= is,
well... =(+ 1 2)=. Though to be fair, that big ugly keyword list in
the middle is optional metadata. The most minimal representation is:

#+BEGIN_SRC elixir
{:+, [], [1, 2]}
#+END_SRC

...which is not /that/ much bigger than the lisp version.

Actually, that gives me an idea. Let's see if we can do this by
constructing sexps instead of with quoting and unquoting.

#+name: exercises
#+BEGIN_SRC elixir
  def my_apply2(func, sequence) do
    {result, _} = Code.eval_quoted({{:., [], [func]}, [], sequence})
    result
  end
#+END_SRC

This is a lot shorter. It feels kind of like working with secret
knowledge though. The Elixir sexp representation is so different from
ordinary written code that it's hard to look at code that /constructs/
code in this way and visualize what it's building.

Here are the tests, just to prove this all works.

#+BEGIN_SRC elixir
  test "my_apply" do
    assert(my_apply(&(&1 + &2), [1,2]) == 3)
  end

  test "my_apply2" do
    assert(my_apply2(&(&1 + &2), [1,2]) == 3)
  end
#+END_SRC

Here I'm using the new [[http://elixir-lang.org/docs/stable/Kernel.SpecialForms.html#&/1][capture operator]], introduced in 0.11.0, to
capture an anonymous function reference to [[http://elixir-lang.org/docs/stable/Kernel.html#%2B/2][=Kernel.+/2=]]:

#+BEGIN_SRC elixir
&(&1 + &2)
#+END_SRC

Believe it or not, this is a lot more concise than the old way. It's
still frustratingly awkward coming from Lisp, Haskell, or pretty much
any other FPL. Or Ruby, for that matter, where we'd probably represent
the function (method) to be applied as simply =:+=. In Clojure, we
take a reference to the =+= function using, wait for it... =+=.

UPDATE: These tests no longer pass on Elixir 0.12.0. They generate
the following error:

#+BEGIN_EXAMPLE
** (CompileError) nofile: anonymous functions cannot be translated into a quoted expression, got: #F
unction<5.78455874 in ExercisesTest.test my_apply2/1>  
#+END_EXAMPLE

I'm not sure how to fix this.

Well, now that I've applied myself (hah!) to this little problem,
let's see how Elixir itself implements =apply=. This is easy, because
the Elixir [[http://elixir-lang.org/docs/stable/Kernel.html#apply/2][API docs]] link directly to the relevant code on
Github. Bless you for that, [[https://github.com/josevalim][Mr. Valim]].

Turns out, Elixir just punts it over to Erlang:

#+BEGIN_SRC elixir
  defmacro apply(fun, args) do
    quote do
      :erlang.apply(unquote(fun), unquote(args))
    end
  end
#+END_SRC

I should have guessed this would be the case.






* FPOO Chapter 1 in Elixir                              :fpoo:elixir:clojure:
  :PROPERTIES:
  :ID:       o2b:e2da1415-8763-47d5-bc21-26a01da342db
  :POST_DATE: [2013-11-20 Wed 09:00]
  :POSTID:   7857
  :BLOG:     virtuouscode
  :CATEGORY: Elixir
  :END:

[boilerplate bypath="fp-oo"]

** Exercise 3: add-squares

First up, we have =add-squares=. Let's write a test...

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-3: add-squares" do
    assert(add_squares([1, 2, 5]) == 30)
  end
#+END_SRC

My Elixir version takes a list rather than a variable number of
arguments, because Erlang doesn't do the varargs thing.

As for implementation...

#+name: exercises
#+BEGIN_SRC elixir
  def add_squares([n|ns]), do: n*n + add_squares(ns)
  def add_squares([]), do: 0
#+END_SRC

Elixir is all about recursion and pattern matching.

(Aside: I understand why it's there, but that darn comma after the
method and before the =do:= when writing one-liners gets me every
freakin' time.)

Hmmm... so far FPOO has avoided introducing =defun=, instead defining
functions by creating them anonymously and then assigning them to a
name. I'm suddenly curious how easy this is in Elixir.

#+BEGIN_SRC elixir
  add_squares = fn
                  [n|ns] -> n*n + add_squares(ns)
                  []     -> 0
                end
#+END_SRC

I realized halfway through writing this that it will lead to a compile
error:

#+BEGIN_EXAMPLE


(CompileError) lib/fp_oo_elx/exercises.ex:17: function add_squares/1 un
defined
#+END_EXAMPLE

I remember now. There's no way (that I'm aware of) to refer to an
anonymous function within itself, so we can't do recursive anonymous
functions in Elixir.

(Aside: why is there no =do= after =fn=???)

OK, I guess I'll stick to named functions. I can always take
anonymous-style references to named functions with the capture (=&=)
operator, so hopefully this won't get in the way.

** Exercise 4: Bizarro-factorial

"Implement a bizarre version of factorial that uses neither iteration
of recursion". Specifically, the instructions say to use =range= and
=apply=.

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-4: bizarro-factorial" do
    assert(bizarro_factorial(5) == 120)
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  def bizarro_factorial(n) do
    (1..n) |> Enum.reduce(&(&1 * &2))
  end
#+END_SRC

This is probably a gratuitous use of the pipeline operator (=|>=),
but I don't care!

Note that FPOO specifies that I use only =range= and =apply=. The
range operator (=..=) is the Elixir equivalent of =range=. On the
other hand, =apply= doesn't really translate well. Sure, Elixir has
it. But Erlang (and thus Elixir) doesn't have the concept of
functions that take arbitrary numbers of arguments, the way =*= in
lisp can yield the product of an arbitrary number of numbers:

#+BEGIN_SRC clj
(* 1 2 3 4 5)
#+END_SRC

Instead, =Kernel.*= is a strictly binary operator. So I have to cheat
and use =Enum.reduce=, which is a recursive function under the covers.

** Exercise 5: Various sequence functions

I'm going to quickly run through these just so I know what the Elixir
equivalents are. I'll use the =Stream= versions when they exist,
since the Clojure versions demonstrated in the book all operate on
potentially lazy sequences.

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-5: sequence functions" do
    # take
    assert(Enum.take([1,2,3], 2) == [1,2])
    # distinct
    assert(Enum.uniq([1,2,1,3,2]) == [1,2,3])
    # concat
    assert(Stream.concat([[1,2], [3,4]]) |> Enum.take(4) == [1,2,3,4])
    # repeat
    xs = Stream.repeatedly(fn -> "x" end)
    assert(xs |> Enum.take(3) == ["x", "x", "x"])
    
    # interleave
    # there appears to be no interleave. There's Enum.zip, which only
    # zips two collections, and isn't lazy(?).
  
    # drop
    assert((1..4) |> Enum.drop(2) == [3,4])
  
    # drop-last
    assert((1..4) |> Enum.slice(0..-2) == [1,2,3])
  
    # flatten
    assert(List.flatten([[1,2], [3,4]]) == [1,2,3,4])
  
    # partition
    assert((1..10) |> Enum.partition(&Integer.even?(&1)) == {[2,4,6,8,10], [1,3,5,7,9]})
  
    # every?
    assert([2,4,6] |> Enum.all?(&Integer.even?(&1)) == true)
    assert([1,4,6] |> Enum.all?(&Integer.even?(&1)) == false)
  
    # remove
    assert((1..10) |> Stream.reject(&Integer.even?/1) |> Enum.take(5) == [1,3,5,7,9])
  end
#+END_SRC

These translations were delightfully easy to do; in almost every
case, the Elixir version of the Clojure function either had a) the
same name; or b) the name of the equivalent operation in Ruby
(e.g. =remove= becomes =reject=).

One thing that has stood out as I've worked through these is that the
=Stream= module is a lot more limited than the =Enum= module. And
from my brief experimentation, =Enum= functions are /not/ lazy. So,
for instance, this expression will never return, even though we are
only trying to take the first three unique items from the stream:

#+BEGIN_SRC elixir
  [1,2,3,4,5] |> Stream.cycle |> Enum.uniq |> Stream.take(3)
#+END_SRC

Evidently =Enum.uniq= tries to convert the stream into a fixed
collection, rather than returning a filtered stream in this case.

Since FPOO is already talking about laziness a lot (and all sequences
seem to be treated as lazy and potentially infinite in Clojure), this
may become a problem for later examples. More broadly, this doesn't
bode well for writing truly generic functions that can process any
kind of collection, including streams, in Elixir. However, Elixir is
still very young, and I suspect that the =Stream= library will grow with
time.




** Exercise 6: prefix-of?

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-6: prefix-of?" do
    assert(prefix_of?([1,2], [1,2,3,4]) == true)
    assert(prefix_of?([2,3], [1,2,3,4]) == false)
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  def prefix_of?(candidate, sequence) do
    import Enum
    size   = count(candidate)
    subseq = sequence |> take(size)
    candidate == subseq
  end
#+END_SRC

** Exercise 7: tails

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-7: tails" do
    assert([1,2,3,4] |> tails == [[1,2,3,4], [2,3,4], [3,4], [4], []])
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir  
  def tails([_|xs] = sequence), do: [sequence|tails(xs)]
  def tails([]), do: [[]]
#+END_SRC

Marick says "my solution is very much in the functional style", and
then goes on to offer some hints having to do with using Clojure's
=range= and =map=. I'm going to go out on a limb and say that the
solution I came up with first is /even more/ in the functional style,
since it relies entirely on destructuring and recursion and doesn't
require any library calls at all.

Just for fun, here's a more direct translation of [[https://github.com/marick/fp-oo/blob/master/solutions/just-enough-clojure.clj#L113][Marick's solution]]:

#+name: tests
#+BEGIN_SRC elixir :exports none
  test "1.18-7: tails2" do
    assert([1,2,3,4] |> tails2 == [[1,2,3,4], [2,3,4], [3,4], [4], []])
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir  
  def tails2(seq) do
    import Enum
    0..count(seq) |> map(&drop(seq, &1))
  end
#+END_SRC

His solution is actually a bit more involved than this, because it
involves mapping over /both/ the range =0..count(seq)= and a repeated
list of the sequence itself. I'm guessing this is because he hasn't
yet explicitly introduced lambdas apart from the top-level function
definitions.

#+BEGIN_SRC clj
  (def tails
    (fn [seq]
      (map drop
           (range (inc (count seq)))
           (repeat (inc (count seq)) seq))))
#+END_SRC

If nothing else, this demonstrates that Clojure's =map= can map over
multiple sequences in parallel, which is kinda cool.

* FPOO Chapters 2 & 3: Basic Objects in Elixir                  :fpoo:elixir:
  :PROPERTIES:
  :ID:       o2b:365e0b20-d58c-4634-baa8-16bd218567a8
  :POST_DATE: [2013-11-25 Mon 09:40]
  :POSTID:   7884
  :BLOG:     virtuouscode
  :CATEGORY: Elixir
  :END:

[boilerplate bypath="fp-oo"]

I feel like I should start with a disclaimer: this post is not
advocating building an OO system on top of an FP language. And anyway,
the Elixir/Erlang "process" model is arguably a very OO system right
out of the box. But this series is about working through the FPOO
book, and the exercise that's up next is to implement a basic OO
system on top of an FP language, so that's what I'm going to do.

First version, without knowledge of class:

#+name: exercises
#+BEGIN_SRC elixir
  defmodule Objects1 do
    import Dict
    def new_point(x, y), do: [x: x, y: y]
    def x(point), do: get(point, :x)
    def y(point), do: get(point, :y)
  end
#+END_SRC

(Note: when I wrote this I either didn't know, or had forgotten, that
subscript/square-bracket access was available in Elixir. So you'll see
a lot of =get(point, :x)= when I probably could have written
=point[:x]=.)

#+name: tests
#+BEGIN_SRC elixir
  defmodule TestObjects1 do
    import FpOoElx.Exercises.Objects1
    test "constructing a Point" do
      p = new_point(3,5)
      assert(x(p) == 3)
      assert(y(p) == 5)
    end
  end
#+END_SRC

Second version, with knowledge of class and =shift= method:

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export
  defmodule TestObjects2 do
    use ExUnit.Case
    import FpOoElx.Exercises.Objects2
    test "constructing a Point" do
      p = new_point(3,5)
      assert(x(p) == 3)
      assert(y(p) == 5)
      assert(class_of(p) == :point)
      p = shift(p, 7, -2)
      assert(x(p) == 10)
      assert(y(p) == 3)      
    end
    doctest FpOoElx.Exercises.Objects2
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir :noweb strip-export
  defmodule Objects2 do
    import Dict
    def new_point(x, y), do: [x: x, y: y, __class_symbol__: :point]
    def x(this), do: get(this, :x)
    def y(this), do: get(this, :y)   
    def class_of(object), do: get(object, :__class_symbol__)
    def shift(this, xinc, yinc), do: new_point(x(this) + xinc, y(this) + yinc)
    <<objects2>>
  end
#+END_SRC


** Exercise 1: Implement add

I think I'll switch over to doctests instead of separate unit tests.

#+name: objects2
#+BEGIN_SRC elixir
  @doc """
  ## Examples:
      iex> p1 = new_point(3, 7)
      iex> p2 = new_point(8, -3)
      iex> p3 = add(p1, p2)
      iex> x(p3)
      11
      iex> y(p3)
      4
  """
  def add(p1, p2), do: shift(p1, x(p2), y(p2))
#+END_SRC


** Exercise 2: A "new" operator

If I did this exactly like the Clojure version I'd have to call it
like this:

#+BEGIN_SRC ruby
make(&new_point/1, [3, 5])
#+END_SRC

Blerg. I'll make a macro instead.

#+name: objects2
#+BEGIN_SRC elixir
  @doc """
  ## Examples
      iex> p = make(point, [3, 5])
      iex> class_of(p)
      :point
      iex> x(p)
      3
      iex> y(p)
      5
  """
  defmacro make(class, args) do
    {classname,_,_} = class
    constructor = binary_to_atom("new_#{classname}")
    quote do
      unquote(constructor)(unquote_splicing(args))
    end
  end
#+END_SRC

OK, that was kinda cool. Of course, if I were willing to put up with
passing the classname as a symbol rather than as a bareword, I
wouldn't need a macro.

#+name: objects2
#+BEGIN_SRC elixir
  @doc """
  ## Examples
      iex> p = make2(:point, [3, 5])
      iex> class_of(p)
      :point
      iex> x(p)
      3
      iex> y(p)
      5
  """
  def make2(class, args) do
    constructor = :"new_#{class}"
    code = {constructor, [], args}
    {result, _} = Code.eval_quoted(code, binding, delegate_locals_to: __MODULE__)
    result
  end
#+END_SRC

Note the use of =delegate_locals_to: __MODULE__= to enable the
=eval_quoted= to find methods in the current module. I'm still
getting the hang of eval-ing in Elixir; there may be a better way to
do this.

The next three exercises involve comparing triangles and I just can't
get excited about that, so I'm gonna stop here.

* FPOO Chapter 4: Encapsulating methods in the constructor      :fpoo:elixir:
  :PROPERTIES:
  :CATEGORY: Elixir
  :ID:       o2b:7896008a-d63d-40e0-981f-9e61fd264b09
  :POST_DATE: [2013-11-27 Wed 15:39]
  :POSTID:   7886
  :BLOG:     virtuouscode
  :END:

[boilerplate bypath="fp-oo"]

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export :exports none
  defmodule TestObjects3 do
    use ExUnit.Case
    import FpOoElx.Exercises.Objects3
    doctest FpOoElx.Exercises.Objects3
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir :exports none
  defmodule Objects3 do
    import Dict
    defmacro make(class, args) do
      {classname,_,_} = class
      constructor = binary_to_atom("new_#{classname}")
      quote do
        unquote(constructor)(unquote_splicing(args))
      end
    end
    <<objects3>>
  end
#+END_SRC

Today I slightly refine the nascent OO implementation in
Elixir. Here's the new =point= constructor, with methods contained
within it:

#+BEGIN_SRC elixir
  def new_point(x, y) do
    [
      x: x, 
      y: y, 
      __class_symbol__: :point,
      __methods__: [
        class: &get(&1, :__class_symbol__),
        shift: fn 
                 (this, xinc, yinc) -> new_point(get(this, :x) + xinc, get(this, :y) + yinc)
               end
      ]
    ]
  end  
#+END_SRC

And here's =send_to=, which (slightly) eases sending messages to
objects.

#+name: objects3
#+BEGIN_SRC elixir
  @doc """
  ## Examples
      iex> p = make(point, [3, 5])
      iex> p2 = send_to(p, :shift, [2,4])
      iex> Dict.get(p2, :x)
      5
      iex> Dict.get(p2, :y)
      9 
  """
  def send_to(object, message, args // []) do
    method_table = get(object, :__methods__)
    method       = get(method_table, message)
    apply(method, [object|args])
  end
#+END_SRC


** Exercise 1: x, y, and add

This exercise re-adds =x=, =y=, and =add= methods.

#+name: objects3
#+BEGIN_SRC elixir
  @doc """
  iex> p1 = make(point, [3,5])
  iex> p2 = make(point, [-2,3])
  iex> p3 = send_to(p1, :add, [p2])
  iex> send_to(p3, :x)
  1
  iex> send_to(p3, :y)
  8
  """
  def new_point(x, y) do
    [
      x: x, 
      y: y, 
      __class_symbol__: :point,
      __methods__: [
        class: &get(&1, :__class_symbol__),
        shift: fn 
                 (this, xinc, yinc) -> new_point(get(this, :x) + xinc, get(this, :y) + yinc)
               end,
        x: &get(&1, :x),
        y: &get(&1, :y),
        add: fn (this, other) -> send_to(this, :shift, [send_to(other, :x), send_to(other, :y)]) end
      ]
    ]
  end  
#+END_SRC

This is all quite horrible so far; presumably I'll be cleaning it up
as I progress further in the book.

* FPOO Chapter 5: Classes                                       :fpoo:elixir:
  :PROPERTIES:
  :CATEGORY: Elixir
  :ID:       o2b:3505a5d0-620f-41ac-949a-9238044f7722
  :POST_DATE: [2013-12-04 Wed 13:25]
  :POSTID:   7895
  :BLOG:     virtuouscode
  :END:

  [boilerplate bypath="fp-oo"]

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export :exports none
  defmodule TestObjects4 do
    use ExUnit.Case
    import FpOoElx.Exercises.Objects4
    doctest FpOoElx.Exercises.Objects4
    <<object_tests4>>
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir :exports none
  defmodule Objects4 do
    import Dict
    <<objects4>>
  end
#+END_SRC

So far, my tiny object system in Elixir has been stowing all methods
directly in instances. Chapter 5 of FPOO directs me to move instance
methods out into a "class" of some kind.

First off, there's no more =new_point=. In its place, a simple keyword
list defining attributes of the class. The instance variables are no
longer hard-coded in the keyword list. Instead, there is a new
=add_instance_values= callback that plays the role of an initializer
method.

#+BEGIN_SRC elixir
  def point() do 
    [
      __own_symbol__: :point,
      __instance_methods__: [
        class: &get(&1, :__class_symbol__),
        add_instance_values: fn (this, x, y) ->
                                  this |> merge([x: x, y: y])
                             end,
        shift: fn (this, xinc, yinc) -> 
                    make(point, [get(this, :x) + xinc, get(this, :y) + yinc])
               end
      ]
    ]
  end
#+END_SRC

Next up, a new =make= function that can use this style of class definition.

#+BEGIN_SRC elixir
  def make(class, args) do
    allocated   = []
    seeded      = allocated |> merge([__class_symbol__: get(class, :__own_symbol__)])
    constructor = class |> get(:__instance_methods__) |> get(:add_instance_values)
    apply(constructor, [seeded|args])
  end
#+END_SRC

Now for message dispatch.

#+BEGIN_SRC elixir
  def send_to(object, message, args // []) do
    class_name = object |> get(:__class_symbol__) 
    class      = apply(__MODULE__, class_name, [])
    method     = class |> get(:__instance_methods__) |> get(message)
    apply(method, [object|args])
  end
#+END_SRC

I gotta say, I kind of prefer Elixir pipelines for chaining keyword
gets:

#+BEGIN_SRC elixir
class |> get(:__instance_methods__) |> get(message)
#+END_SRC

...to Clojure nested function calls:

#+BEGIN_SRC clj
(let [method (message (:__instance_methods__ class))])
#+END_SRC

(EDIT: I had either forgotten or didn't yet know about subscript
(=[]=) access when this was written)

Before I go any further, let's see if any of this is working.

#+name: object_tests4
#+BEGIN_SRC elixir
  test "class-based object creation" do
    import Dict
    p = make(point, [23, 42])
    assert(get(p, :x) == 23)
    assert(get(p, :y) == 42)
    p2 = send_to(p, :shift, [2, 3])
    assert(get(p2, :x) == 25)
    assert(get(p2, :y) == 45)
  end
#+END_SRC


*** Exercise 1: apply-message-to

A small refactoring to pull out this helper method:

#+name: objects4
#+BEGIN_SRC elixir
  def apply_message_to(class, object, message, args) do
    method = class |> get(:__instance_methods__) |> get(message)
    apply(method, [object|args])
  end  
#+END_SRC

Now the =make= and =send_to= functions can be refactored to use this new helper method.

#+name: objects4
#+BEGIN_SRC elixir
  def make(class, args) do
    allocated   = []
    seeded      = allocated |> merge([__class_symbol__: get(class, :__own_symbol__)])
    apply_message_to(class, seeded, :add_instance_values, args)
  end
#+END_SRC

#+name: objects4
#+BEGIN_SRC elixir
  def send_to(object, message, args // []) do
    class_name = object |> get(:__class_symbol__) 
    class      = apply(__MODULE__, class_name, [])
    apply_message_to(class, object, message, args)
  end
#+END_SRC


*** Exercise 2: class and class-name

The behavior I want:

#+name: object_tests4
#+BEGIN_SRC elixir
  test "class and class name" do
    p = make(point, [23, 42])
    assert(send_to(p, :class) == point)
    assert(send_to(p, :class_name) == :point)
  end
#+END_SRC

This necessitates a change to the class definition:

#+name: objects4
#+BEGIN_SRC elixir
  def point() do 
    [
      __own_symbol__: :point,
      __instance_methods__: [
        class_name: &get(&1, :__class_symbol__),
        class: fn (_this) -> point end,
        add_instance_values: fn (this, x, y) ->
                                  this |> merge([x: x, y: y])
                             end,
        shift: fn (this, xinc, yinc) -> 
                    make(point, [get(this, :x) + xinc, get(this, :y) + yinc])
               end
      ]
    ]
  end
#+END_SRC

* FPOO Chapter 6: Inheritance
  :PROPERTIES:
  :CATEGORY: Elixir
  :ID:       o2b:4da4c3d1-613a-4f9d-9cd4-af7f85bff1bd
  :POST_DATE: [2013-12-09 Mon 12:18]
  :POSTID:   7897
  :BLOG:     virtuouscode
  :END:
  [boilerplate bypath="fp-oo"]

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export :exports none
  defmodule TestObjects5 do
    use ExUnit.Case
    import FpOoElx.Exercises.Objects5
    doctest FpOoElx.Exercises.Objects5
    <<object_tests4>>
    <<object_tests5>>
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir :exports none
  defmodule Objects5 do
    import Dict
    <<objects5>>
  end
#+END_SRC

#+BEGIN_SRC elixir :exports none
  defp apply_message_to(class, object, message, args) do
    method = class |> get(:__instance_methods__) |> get(message)
    apply(method, [object|args])
  end  
#+END_SRC

#+name: objects5
#+BEGIN_SRC elixir :exports none
  def make(class, args) do
    allocated   = []
    seeded      = allocated |> merge([__class_symbol__: get(class, :__own_symbol__)])
    apply_message_to(class, seeded, :add_instance_values, args)
  end
#+END_SRC

#+name: objects5
#+BEGIN_SRC elixir :exports none
  def send_to(object, message, args // []) do
    class_name = object |> get(:__class_symbol__) 
    class      = apply(__MODULE__, class_name, [])
    apply_message_to(class, object, message, args)
  end
#+END_SRC

Inheritance means knowing who your parent is.

#+name: objects5
#+BEGIN_SRC elixir
  def point() do 
    [
      __own_symbol__: :point,
      __superclass_symbol__: :anything,
      __instance_methods__: [
        class: fn (_this) -> point end,
        add_instance_values: fn (this, x, y) ->
                                  this |> merge([x: x, y: y])
                             end,
        shift: fn (this, xinc, yinc) -> 
                    make(point, [get(this, :x) + xinc, get(this, :y) + yinc])
               end
      ]
    ]
  end
#+END_SRC

Now to define the =anything= class, referenced above by the keyword
=:__superclass_symbol__=.

#+name: objects5
#+BEGIN_SRC elixir
  def anything do
    [
      __own_symbol__: :anything,
      __instance_methods__: [
        add_instance_values: fn(this) -> this end,
        class_name: &get(&1, :__class_symbol__),
        class: fn 
          (this) -> apply(__MODULE__, get(this, :__class_symbol__), [])
        end
      ] 
    ]
  end
#+END_SRC

And now the real magic: method lookup!

The top-level method lookup function:

#+BEGIN_SRC elixir
  def method_cache(class) do
    import Enum
    class_symbol = class |> get(:__own_symbol__)
    method_maps  = lineage(class_symbol) |> map(&class_instance_methods/1)
    method_maps |> reduce(&Dict.merge(&2, &1))
  end
#+END_SRC

Notice that I've had to reverse the order of the arguments to
=Dict.merge/2=. This is because =reduce= passes arguments in the order
=next_item, accumulator=, but I want methods from each successive
class in the lineage to override methods in earlier, less-specialized
classes.

A helper to get the instance methods defined for a class:

#+name: objects5
#+BEGIN_SRC elixir
def class_instance_methods(class_symbol) do
  apply(__MODULE__, class_symbol, []) |> get(:__instance_methods__)
end
#+END_SRC

Another helper to get the parent class symbol:

#+name: objects5
#+BEGIN_SRC elixir
def class_symbol_above(class_symbol) do
  apply(__MODULE__, class_symbol, []) |> get(:__superclass_symbol__)
end
#+END_SRC

...and a function to get the ancestry chain of a given class:

#+name: objects5
#+BEGIN_SRC elixir
  @doc """
    iex> lineage(:point)
    [:anything, :point]
  """
  def lineage(nil), do: []  
  def lineage(class_symbol) do
    [class_symbol|class_symbol |> class_symbol_above |> lineage] |> Enum.reverse
  end
#+END_SRC

Now to update =apply_message_to= to use this new code:

#+name: objects5
#+BEGIN_SRC elixir
  defp apply_message_to(class, object, message, args) do
    class |> method_cache |> get(message) |> apply([object|args])
  end  
#+END_SRC

Before I go any further, I feel a compulsion to try and golf down the
=method_cache= function.

#+name: objects5
#+BEGIN_SRC elixir
  def method_cache(class) do
    import Enum
    class 
    |> get(:__own_symbol__)
    |> lineage
    |> map(&class_instance_methods/1)
    |> reduce(&Dict.merge(&2, &1))
  end
#+END_SRC

Ah, lovely.

*** Exercise 1: factorial

Just for fun, I'll do this one in a single definition instead of multiple
pattern-matching definitions.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
    iex> factorial(5)
    120
  """
  def factorial(n) do
    case n do
      0 -> 1
      1 -> 1
      _ -> n*factorial(n-1)
    end
  end
#+END_SRC

*** Exercise 2: factorial, accumulator style

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
    iex> factorial_acc(5)
    120
    iex> factorial_acc(0)
    1
  """
  def factorial_acc(n, acc // 1) do
    if n == 0 || n == 1 do
      acc
    else
      factorial_acc(n-1, n*acc)
    end
  end
#+END_SRC


*** Exercises 3-6: implementing reduce

I'm going to skip these for now.


*** Notes

One of the things I like about this section, and this book, is that
Marick explicitly identifies functional patterns, such as the two
styles of recursive method definition. He even shows "ideal forms" of
the two patterns, with placeholders for the parts that change.

I've definitely seen these styles in use, but hadn't seen them clearly
elucidated as patterns before. If nothing else, this book should put
the rest the notion, occasionally advanced, that patterns are somehow
not applicable to functional programming. Every community develops
patterns; being able to identify them and point out which parts are
consistent and which parts change with the application is one of the
marks of a good software writer.

* FPOO Chapter 7: Programming with Dataflow                     :fpoo:elixir:
  :PROPERTIES:
  :CATEGORY: Elixir
  :ID:       o2b:61662969-535e-45ff-8bd7-2fe66f856016
  :POST_DATE: [2013-12-12 Thu 11:28]
  :POSTID:   7902
  :BLOG:     virtuouscode
  :END:

  [boilerplate bypath="fp-oo"]

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export :exports none
  defmodule SchedulingTests do
    use ExUnit.Case
    import FpOoElx.Exercises.Scheduling
    doctest FpOoElx.Exercises.Scheduling
    <<scheduling_tests>>
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir :exports none
  defmodule Scheduling do
    import Enum
    import Set
    import Dict
    <<scheduling_exercises>>
  end
#+END_SRC

This is where FPOO starts to get interesting. I have to say I find the
choice of the term "dataflow" confusing due to its [[http://en.wikipedia.org/wiki/Dataflow_programming][other associations]]
in programming. But this section introduces a style of working with
data--first annotating it, then filtering it--which I've never really
given a lot of thought to.

I'm going to start out by defining a record type for courses. Marick
doesn't do this for his example, but Clojure has more shortcuts for
working with raw maps (e.g. being able to use a key as a function of
the map). I'm curious if this kind of dataflow programming is easy to
adapt to records.

#+name: scheduling_exercises
#+BEGIN_SRC elixir
  defrecord Course, course_name: nil, morning?: true, limit: Infinity, registered: 0
#+END_SRC

Let me just make sure I know how to use records.

#+name: scheduling_tests
#+BEGIN_SRC elixir
  test "Course" do
    alias FpOoElx.Exercises.Scheduling.Course
    c = Course[course_name: "Zigging", morning?: true, limit: 5, registered: 3]
    assert c.course_name == "Zigging"
    
    # Or the more functional style attribute access
    import Course
    assert morning?(c) == true

    assert c.to_keywords ==
      List.keysort([course_name: "Zigging", morning?: true, limit: 5, registered: 3], 0)

    c2 = c.limit(10)
    assert c2.limit == 10
  end
#+END_SRC

OK, now on to the first metadata-annotating function.

#+name: scheduling_exercises
#+BEGIN_SRC elixir
  def answer_annotations(courses, registrants_courses) do
    checking_set = registrants_courses
    courses |> map fn(course)->
      course_attrs = course.to_keywords
      course_attrs |> merge(
        spaces_left: course.limit - course.registered,
        already_in?: checking_set |> Enum.member?(course.course_name))
    end
  end                                                                                
#+END_SRC

#+name: scheduling_tests
#+BEGIN_SRC elixir
  test "answer_annotations" do
    alias FpOoElx.Exercises.Scheduling.Course
    import Enum
    courses = [Course[course_name: "zigging", limit: 4, registered: 3],
               Course[course_name: "zagging", limit: 1, registered: 1]]
    annotated = courses |> answer_annotations(["zagging"])
    assert at(annotated, 0)[:already_in?] == false
    assert at(annotated, 0)[:spaces_left] == 1
    assert at(annotated, 1)[:already_in?] == true
    assert at(annotated, 1)[:spaces_left] == 0
  end
#+END_SRC

And now the second. This one differs from the first in that it
assumes it will get keyword lists instead of a records. This is a
strike against using records in the first place, since now these two
functions differ in this seemingly arbitrary way.

#+name: scheduling_exercises
#+BEGIN_SRC elixir
  def domain_annotations(courses) do
    courses |> map fn(course)->
      course |> merge(
        empty?: course[:registered] == 0,
        full?:  course[:spaces_left] == 0)
    end
  end                                                                                
#+END_SRC

#+name: scheduling_tests
#+BEGIN_SRC elixir
  test "domain_annotations" do
    import Enum
    annotated = [[registered: 1, spaces_left: 1],
                 [registered: 0, spaces_left: 1],
                 [registered: 1, spaces_left: 0]] |> domain_annotations
    assert at(annotated, 0)[:full?] == false
    assert at(annotated, 0)[:empty?] == false
    assert at(annotated, 1)[:full?] == false
    assert at(annotated, 1)[:empty?] == true
    assert at(annotated, 2)[:full?] == true
    assert at(annotated, 2)[:empty?] == false
  end
#+END_SRC

And now the final annotation function, which adds notes on course
availability.

#+name: scheduling_exercises
#+BEGIN_SRC elixir
  def note_unavailability(courses, instructor_count) do
    out_of_instructors? = 
      instructor_count ==
      (courses |> filter(&not(empty?(&1))) |> count)
    courses |> map fn(course) ->
      course |> merge(
        unavailable?: course[:full?] || (out_of_instructors? && course[:empty?]))
    end
  end
#+END_SRC

I'm pleasantly surprised I can use the capture operator for the
nested =&not(empty?(&1))= expression.

Finally, the payoff. At this point the book introduces the arrow
(=->=) operator for threading functions together, but of course this
is Elixir so we do that all the time.

#+name: scheduling_exercises
#+BEGIN_SRC elixir
  def annotate(courses, registrants_courses, instructor_count) do
    courses |> answer_annotations(registrants_courses)
            |> domain_annotations
            |> note_unavailability(instructor_count)
  end    
#+END_SRC

I'm tired of translating now, but I'm going to do one quick check
that this works as expected.

#+name: scheduling_tests
#+BEGIN_SRC elixir
  test "annotate" do
    import Enum
    alias FpOoElx.Exercises.Scheduling.Course
    courses = [
      Course[course_name: "zigging", limit: 4, registered: 3],
      Course[course_name: "zagging", limit: 1, registered: 1]
    ]
    registrants_courses = ["zigging"]
    instructor_count = 2
    annotated = courses |> annotate(registrants_courses, instructor_count)
    assert at(annotated, 0)[:unavailable?] == false
    assert at(annotated, 1)[:unavailable?] == true
  end
#+END_SRC

(I'd really like to find a way to avoid having to explicitly alias the
Course type, and instead have it show up when importing the
=Scheduling= module it lives in.)

This has been instructive, but time-consuming. Enough for now.

* FPOO Ch. 9: Functions That Make Functions                     :fpoo:elixir:
  :PROPERTIES:
  :CATEGORY: Elixir
  :ID:       o2b:d5a041e7-6920-4c31-986f-0b197c6804e1
  :POST_DATE: [2013-12-16 Mon 10:37]
  :POSTID:   7904
  :BLOG:     virtuouscode
  :END:

  [boilerplate bypath="fp-oo"]

Unlike Clojure, as far as I know Elixir does not have a library of
foundational higher-order functions such as like =lift= or
=complement=. So I'll have to build them myself.

Before I do anything else, I need a helper function for adapting the
arity of anonymous functions. This is because Elixir has no support
for variable-arity functions. As a result, the only workable way I can
find to build generic functions involves always returning a function
of a single argument, where the single argument is a list of the
actual arguments. Which can then be used with =apply=, etc.

This works, but it's pretty unpleasant to have to call all generated
functions as, e.g. =add2.([2])= instead of =add2.(2)=. Not to mention
that in order to be composable, any function-modifying-function would
have to have two versions: one that accepts a "normal" function of N
arguments, and one that takes a function of single argument list. 

So instead I define =adapt_arity=, which takes a function of one
argument and an arity, and returns a function of =arity= arguments.

I spent a few days off and on trying to come up with a clean macro
version of this, but I completely struck out. The problem I kept
running into is that the macro is evaluated at compile time, but the
arity number is only discovered at runtime. Eventually I reluctantly
settled on using =Code.eval_string= instead.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
     iex> myfun = fn(args) -> args end
     iex> myfun3 = adapt_arity(myfun, 3)
     iex> myfun3.(:a, :b, :c)
     [:a, :b, :c]
     iex> myfun2 = adapt_arity(myfun, 2)
     iex> myfun2.(:x, :y)
     [:x, :y]
  """
  def adapt_arity(fun, arity) do
    arglist = (0..arity - 1) |> Enum.map(fn(n) -> "arg#{n}" end) |> Enum.join(", ")
    code = """
      fn(#{arglist}) ->
        args = [#{arglist}]
        fun.(args)
      end
    """
    {value, _binding} = Code.eval_string(code, binding, __ENV__)
    value
  end
#+END_SRC

(I even tried a version that eval-ed code at compile time to generate
256 different versions of =adapt_arity=, but then I ran into an issue
where I couldn't get the =Code.eval_*= functions to eval in the
context of a given module. Instead they were evaluating in the
global(?)  context, and functions can't be defined outside a module.)

UPDATE: Where I failed, [[https://twitter.com/meh99][meh]] succeeded. Check out this masterful
rewrite using macros instead of evaluation:
https://gist.github.com/meh/7990856/c59f69216418e27bd01f43f47262af6870c8874a

UPDATE: José Valim weighs in with an unrolled version that actually
works, unlike my attempt:
https://gist.github.com/josevalim/ea084b59f88de1ab6d35

UPDATE: Here's the gist from meh, updated with the compile-time unrolling
approach: https://gist.github.com/meh/7990856

Given a call like this:

#+BEGIN_SRC elixir
  adapt_arity(myfun, 3)
#+END_SRC

The following anonymous function will be returned from =adapt_arity=:

#+BEGIN_SRC elixir
  fn(arg0, arg1, arg2) ->
    args = [arg0, arg1, arg2]
    myfun.(args)
  end  
#+END_SRC

I also define a helper function to discover the arity of a given
anonymous function.

#+BEGIN_SRC elixir
  @doc """
      iex> arity(&Kernel.even?/1)
      1
      iex> arity(&Kernel.+/2)
      2
  """
  def arity(fun) do
    (0..255) |> Enum.find fn(arity) -> is_function(fun, arity) end
  end
#+END_SRC

The magic number 255 corresponds to [[http://www.erlang.org/doc/efficiency_guide/advanced.html][the upper bound of arguments an
Erlang function can take]].

So far as I can tell there's no built-in way to check the arity of a
function. This was the best I could come up with. I suspect this could
be made more efficient by unrolling it into a pattern-matching
version, if someone really wanted to.

UPDATE: On IRC, [[https://twitter.com/meh99][meh]] pointed me to the fun_info, which simplifies this
function considerably.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> arity(&Kernel.even?/1)
      1
      iex> arity(&Kernel.+/2)
      2
  """
  def arity(fun) do
    {:arity, value} = :erlang.fun_info(fun, :arity)
    value
  end
#+END_SRC

Now on to the various function adapters. First up, =partial=.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> add2 = partial(&Kernel.+/2, [2])
      iex> add2.(4)
      6
  """
  def partial(fun, partial_args) do
    arity = arity(fun) - length(partial_args)
    fn(args) -> apply(fun, partial_args ++ args) end |> adapt_arity(arity)
  end
#+END_SRC

Next, =complement=.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> not_even = complement(&Integer.even?/1)
      iex> not_even.(2)
      false
      iex> not_even.(3)
      true
  """
  def complement(fun) do
    fn(args) -> !apply(fun, args) end |> adapt_arity(arity(fun))
  end
#+END_SRC

And now =lift=, which effectively turns a function into a function
modifier.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> negate = lift(&Kernel.-/1)
      iex> neg_add = negate.(&Kernel.+/2)
      iex> neg_add.(2, 2)
      -4
  """
  def lift(modifier) do
    fn(base_function) ->      
        fn(args) -> 
            result = apply(base_function, args)
            modifier.(result)
        end |> adapt_arity(arity(base_function))
    end
  end
#+END_SRC

Finally, =comp=, to compose N functions together.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> plus = &Kernel.+/2
      iex> add = &Enum.reduce(&1, plus)
      iex> comp([&Kernel.to_string/1, add]).([8, 8, 8])
      "24"
  """
  def comp(funs) do
    rfuns = funs |> Enum.reverse
    arity = arity(funs |> Enum.first)
    rfuns |> Enum.reduce fn(outer, inner) ->
                             fn(args) ->
                                 outer.(apply(inner, args))
                             end |> adapt_arity(arity(inner))
                         end
  end  
#+END_SRC

The compact code for =comp= doesn't really reflect the amount of brain
pain that went into working it out. For some reason I have a hard time
reasoning about reductions involving function composition.

Oops, one more: =juxt=.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> juxt([&Enum.empty?/1, &Enum.reverse/1, &Enum.count/1]).([:a, :b, :c])
      [false, [:c, :b, :a], 3]
  """
  def juxt(funs) do
    fn(arg) ->
        funs |> Enum.map(fn(fun) -> fun.(arg) end)
    end
  end  
#+END_SRC

Exercise 1 challenges me to write a function that adds 2 to each
element of a sequence, using a point-free style (no =fn= allowed).

This would be easy enough with just the capture (=&=) operator, but
since I've got a shiny new =partial= function, I'll use it.

#+name: tests
#+BEGIN_SRC elixir
  test "add 2 to each element, using a point-free style" do
    result = [1,2,3] |> Enum.map(partial(&Kernel.+/2, [2]))
    assert result == [3,4,5]
  end
#+END_SRC

This might draw the question "if the capture operator would have
worked just as well, what's the point of =partial=?" The answer is
genericity. =partial= can be used within other functions where the
number of partial arguments to be supplied isn't known until
runtime. That's not possible with captures.

Exercise 2 is to write a =separate= function using =juxt=.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> separate([0,1,2,3], &Integer.odd?/1)
      [[1,3], [0,2]]
  """
  def separate(list, pred) do
    juxt([&Enum.filter(&1, pred), &Enum.reject(&1, pred)]).(list)
  end
#+END_SRC

Exercise 6 is to write =always=, a function that generates functions
that always return a constant value regardless of arguments. As usual,
Elixir complicates things by requiring an explicit arity.

#+name: exercise
#+BEGIN_SRC elixir
  @doc """
      iex> eight = always(8, 3)
      iex> eight.(1,2,3)
      8
  """
  def always(value, arity) do
    fn(_) -> value end |> adapt_arity(arity)
  end
#+END_SRC

Exercises 7 and 8 deal with validating ISBNs.

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> check_sum([4, 8, 9, 3, 2])
      69
  """
  def check_sum(digits) do
    import Enum
    digits 
    |> zip(1..length(digits))
    |> reduce(0, fn({digit, index}, sum) ->
                     sum + (digit * index)
                 end)
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  @doc """
      iex> isbn?("0131774115")
      true
      iex> isbn?("0977716614")
      false
      iex> isbn?("1934356190")
      true
  """
  def isbn?(num) do
    digits = String.graphemes(num) |> Enum.map(&binary_to_integer/1)
    rem(check_sum(digits), 11) == 0
  end
#+END_SRC

And that's enough for now.


