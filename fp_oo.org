#+TITLE: FPOO in Elixir
#+OPTIONS: num:nil ^:nil toc:nil

* Setup

Let's define a module to keep exercises in.

#+name: exercises_module
#+BEGIN_SRC elixir :tangle lib/fp_oo_elx/exercises.ex :noweb yes
  defmodule FpOoElx.Exercises do
    <<exercises>>
  end
#+END_SRC

And a module to keep tests in.

#+name: tests_module
#+BEGIN_SRC elixir :tangle test/exercises_test.exs :noweb yes
  defmodule ExercisesTest do
    use ExUnit.Case
    import FpOoElx.Exercises
    <<tests>>
    doctest FpOoElx.Exercises
  end
#+END_SRC

* Re-implementing apply in Elixir                               :fpoo:elixir:
   :PROPERTIES:
   :ID:       o2b:6e62c054-5535-4cd8-8b37-51b176ad4585
   :POST_DATE: [2013-11-18 Mon 09:00]
   :POSTID:   7849
   :BLOG:     virtuouscode
   :CATEGORY: Elixir
   :END:

[boilerplate bypath="fp-oo"]

Elixir already has a perfectly good [[http://elixir-lang.org/docs/stable/Kernel.html#apply/2][=apply=]]. But [[https://leanpub.com/fp-oo][FPOO]] suggests I try
to write my own version, and why not?

#+name: exercises
#+BEGIN_SRC elixir
  def my_apply(func, sequence) do
    code = quote do
      unquote(func).(unquote_splicing(sequence))
    end
    {result, _} = Code.eval_quoted(code)
    result
  end
#+END_SRC

This is considerably more verbose than the Clojure example in the
book, without really seeming to add much expressiveness:

#+BEGIN_SRC clj
  (def my-apply
    (fn [function sequence]
      (eval (cons function sequence))))
#+END_SRC

Perhaps an Elixir-experienced reader can show me a more idiomatic
form. Although I think Elixir metaprogramming is likely always going
to be wordier than Lisp because of a) its less-concise
quoting/unquoting constructs; and b) the fact that the sexp-ish things
that Elixir macros work on under the covers are more complex than
their lisp counterparts. As an example, here's the code-as-data
version of adding two integers:

#+BEGIN_SRC elixir
quote do: 1 + 2
# => {:+, [context: Elixir, import: Kernel], [1, 2]}
#+END_SRC

Whereas the lisp code-as-data representation of =(+ 1 2)= is,
well... =(+ 1 2)=. Though to be fair, that big ugly keyword list in
the middle is optional metadata. The most minimal representation is:

#+BEGIN_SRC elixir
{:+, [], [1, 2]}
#+END_SRC

...which is not /that/ much bigger than the lisp version.

Actually, that gives me an idea. Let's see if we can do this by
constructing sexps instead of with quoting and unquoting.

#+name: exercises
#+BEGIN_SRC elixir
  def my_apply2(func, sequence) do
    {result, _} = Code.eval_quoted({{:., [], [func]}, [], sequence})
    result
  end
#+END_SRC

This is a lot shorter. It feels kind of like working with secret
knowledge though. The Elixir sexp representation is so different from
ordinary written code that it's hard to look at code that /constructs/
code in this way and visualize what it's building.

Here are the tests, just to prove this all works.

#+name: tests
#+BEGIN_SRC elixir
  test "my_apply" do
    assert(my_apply(&(&1 + &2), [1,2]) == 3)
  end

  test "my_apply2" do
    assert(my_apply2(&(&1 + &2), [1,2]) == 3)
  end
#+END_SRC

Here I'm using the new [[http://elixir-lang.org/docs/stable/Kernel.SpecialForms.html#&/1][capture operator]], introduced in 0.11.0, to
capture an anonymous function reference to [[http://elixir-lang.org/docs/stable/Kernel.html#%2B/2][=Kernel.+/2=]]:

#+BEGIN_SRC elixir
&(&1 + &2)
#+END_SRC

Believe it or not, this is a lot more concise than the old way. It's
still frustratingly awkward coming from Lisp, Haskell, or pretty much
any other FPL. Or Ruby, for that matter, where we'd probably represent
the function (method) to be applied as simply =:+=. In Clojure, we
take a reference to the =+= function using, wait for it... =+=.

Well, now that I've applied myself (hah!) to this little problem,
let's see how Elixir itself implements =apply=. This is easy, because
the Elixir [[http://elixir-lang.org/docs/stable/Kernel.html#apply/2][API docs]] link directly to the relevant code on
Github. Bless you for that, [[https://github.com/josevalim][Mr. Valim]].

Turns out, Elixir just punts it over to Erlang:

#+BEGIN_SRC elixir
  defmacro apply(fun, args) do
    quote do
      :erlang.apply(unquote(fun), unquote(args))
    end
  end
#+END_SRC

I should have guessed this would be the case.





* FPOO Chapter 1 in Elixir                              :fpoo:elixir:clojure:
  :PROPERTIES:
  :ID:       o2b:e2da1415-8763-47d5-bc21-26a01da342db
  :POST_DATE: [2013-11-20 Wed 09:00]
  :POSTID:   7857
  :BLOG:     virtuouscode
  :CATEGORY: Elixir
  :END:

[boilerplate bypath="fp-oo"]

** Exercise 3: add-squares

First up, we have =add-squares=. Let's write a test...

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-3: add-squares" do
    assert(add_squares([1, 2, 5]) == 30)
  end
#+END_SRC

My Elixir version takes a list rather than a variable number of
arguments, because Erlang doesn't do the varargs thing.

As for implementation...

#+name: exercises
#+BEGIN_SRC elixir
  def add_squares([n|ns]), do: n*n + add_squares(ns)
  def add_squares([]), do: 0
#+END_SRC

Elixir is all about recursion and pattern matching.

(Aside: I understand why it's there, but that darn comma after the
method and before the =do:= when writing one-liners gets me every
freakin' time.)

Hmmm... so far FPOO has avoided introducing =defun=, instead defining
functions by creating them anonymously and then assigning them to a
name. I'm suddenly curious how easy this is in Elixir.

#+BEGIN_SRC elixir
  add_squares = fn
                  [n|ns] -> n*n + add_squares(ns)
                  []     -> 0
                end
#+END_SRC

I realized halfway through writing this that it will lead to a compile
error:

#+BEGIN_EXAMPLE


(CompileError) lib/fp_oo_elx/exercises.ex:17: function add_squares/1 un
defined
#+END_EXAMPLE

I remember now. There's no way (that I'm aware of) to refer to an
anonymous function within itself, so we can't do recursive anonymous
functions in Elixir.

(Aside: why is there no =do= after =fn=???)

OK, I guess I'll stick to named functions. I can always take
anonymous-style references to named functions with the capture (=&=)
operator, so hopefully this won't get in the way.

** Exercise 4: Bizarro-factorial

"Implement a bizarre version of factorial that uses neither iteration
of recursion". Specifically, the instructions say to use =range= and
=apply=.

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-4: bizarro-factorial" do
    assert(bizarro_factorial(5) == 120)
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  def bizarro_factorial(n) do
    (1..n) |> Enum.reduce(&(&1 * &2))
  end
#+END_SRC

This is probably a gratuitous use of the pipeline operator (=|>=),
but I don't care!

Note that FPOO specifies that I use only =range= and =apply=. The
range operator (=..=) is the Elixir equivalent of =range=. On the
other hand, =apply= doesn't really translate well. Sure, Elixir has
it. But Erlang (and thus Elixir) doesn't have the concept of
functions that take arbitrary numbers of arguments, the way =*= in
lisp can yield the product of an arbitrary number of numbers:

#+BEGIN_SRC clj
(* 1 2 3 4 5)
#+END_SRC

Instead, =Kernel.*= is a strictly binary operator. So I have to cheat
and use =Enum.reduce=, which is a recursive function under the covers.

** Exercise 5: Various sequence functions

I'm going to quickly run through these just so I know what the Elixir
equivalents are. I'll use the =Stream= versions when they exist,
since the Clojure versions demonstrated in the book all operate on
potentially lazy sequences.

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-5: sequence functions" do
    # take
    assert(Enum.take([1,2,3], 2) == [1,2])
    # distinct
    assert(Enum.uniq([1,2,1,3,2]) == [1,2,3])
    # concat
    assert(Stream.concat([[1,2], [3,4]]) |> Enum.take(4) == [1,2,3,4])
    # repeat
    xs = Stream.repeatedly(fn -> "x" end)
    assert(xs |> Enum.take(3) == ["x", "x", "x"])
    
    # interleave
    # there appears to be no interleave. There's Enum.zip, which only
    # zips two collections, and isn't lazy(?).
  
    # drop
    assert((1..4) |> Enum.drop(2) == [3,4])
  
    # drop-last
    assert((1..4) |> Enum.slice(0..-2) == [1,2,3])
  
    # flatten
    assert(List.flatten([[1,2], [3,4]]) == [1,2,3,4])
  
    # partition
    assert((1..10) |> Enum.partition(&Integer.even?(&1)) == {[2,4,6,8,10], [1,3,5,7,9]})
  
    # every?
    assert([2,4,6] |> Enum.all?(&Integer.even?(&1)) == true)
    assert([1,4,6] |> Enum.all?(&Integer.even?(&1)) == false)
  
    # remove
    assert((1..10) |> Stream.reject(&Integer.even?/1) |> Enum.take(5) == [1,3,5,7,9])
  end
#+END_SRC

These translations were delightfully easy to do; in almost every
case, the Elixir version of the Clojure function either had a) the
same name; or b) the name of the equivalent operation in Ruby
(e.g. =remove= becomes =reject=).

One thing that has stood out as I've worked through these is that the
=Stream= module is a lot more limited than the =Enum= module. And
from my brief experimentation, =Enum= functions are /not/ lazy. So,
for instance, this expression will never return, even though we are
only trying to take the first three unique items from the stream:

#+BEGIN_SRC elixir
  [1,2,3,4,5] |> Stream.cycle |> Enum.uniq |> Stream.take(3)
#+END_SRC

Evidently =Enum.uniq= tries to convert the stream into a fixed
collection, rather than returning a filtered stream in this case.

Since FPOO is already talking about laziness a lot (and all sequences
seem to be treated as lazy and potentially infinite in Clojure), this
may become a problem for later examples. More broadly, this doesn't
bode well for writing truly generic functions that can process any
kind of collection, including streams, in Elixir. However, Elixir is
still very young, and I suspect that the =Stream= library will grow with
time.




** Exercise 6: prefix-of?

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-6: prefix-of?" do
    assert(prefix_of?([1,2], [1,2,3,4]) == true)
    assert(prefix_of?([2,3], [1,2,3,4]) == false)
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  def prefix_of?(candidate, sequence) do
    import Enum
    size   = count(candidate)
    subseq = sequence |> take(size)
    candidate == subseq
  end
#+END_SRC

** Exercise 7: tails

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-7: tails" do
    assert([1,2,3,4] |> tails == [[1,2,3,4], [2,3,4], [3,4], [4], []])
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir  
  def tails([_|xs] = sequence), do: [sequence|tails(xs)]
  def tails([]), do: [[]]
#+END_SRC

Marick says "my solution is very much in the functional style", and
then goes on to offer some hints having to do with using Clojure's
=range= and =map=. I'm going to go out on a limb and say that the
solution I came up with first is /even more/ in the functional style,
since it relies entirely on destructuring and recursion and doesn't
require any library calls at all.

Just for fun, here's a more direct translation of [[https://github.com/marick/fp-oo/blob/master/solutions/just-enough-clojure.clj#L113][Marick's solution]]:

#+name: tests
#+BEGIN_SRC elixir :exports none
  test "1.18-7: tails2" do
    assert([1,2,3,4] |> tails2 == [[1,2,3,4], [2,3,4], [3,4], [4], []])
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir  
  def tails2(seq) do
    import Enum
    0..count(seq) |> map(&drop(seq, &1))
  end
#+END_SRC

His solution is actually a bit more involved than this, because it
involves mapping over /both/ the range =0..count(seq)= and a repeated
list of the sequence itself. I'm guessing this is because he hasn't
yet explicitly introduced lambdas apart from the top-level function
definitions.

#+BEGIN_SRC clj
  (def tails
    (fn [seq]
      (map drop
           (range (inc (count seq)))
           (repeat (inc (count seq)) seq))))
#+END_SRC

If nothing else, this demonstrates that Clojure's =map= can map over
multiple sequences in parallel, which is kinda cool.




* FPOO Chapters 2 & 3: Basic Objects in Elixir                  :fpoo:elixir:

[boilerplate bypath="fp-oo"]

First version, without knowledge of class:

#+name: exercises
#+BEGIN_SRC elixir
  defmodule Objects1 do
    import Dict
    def new_point(x, y), do: [x: x, y: y]
    def x(point), do: get(point, :x)
    def y(point), do: get(point, :y)
  end
#+END_SRC

#+name: tests
#+BEGIN_SRC elixir
  defmodule TestObjects1 do
    import FpOoElx.Exercises.Objects1
    test "constructing a Point" do
      p = new_point(3,5)
      assert(x(p) == 3)
      assert(y(p) == 5)
    end
  end
#+END_SRC

Second version, with knowledge of class and =shift= method:

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export
  defmodule TestObjects2 do
    use ExUnit.Case
    import FpOoElx.Exercises.Objects2
    test "constructing a Point" do
      p = new_point(3,5)
      assert(x(p) == 3)
      assert(y(p) == 5)
      assert(class_of(p) == :point)
      p = shift(p, 7, -2)
      assert(x(p) == 10)
      assert(y(p) == 3)      
    end
    doctest FpOoElx.Exercises.Objects2
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  defmodule Objects2 do
    import Dict
    def new_point(x, y), do: [x: x, y: y, __class_symbol__: :point]
    def x(this), do: get(this, :x)
    def y(this), do: get(this, :y)   
    def class_of(object), do: get(object, :__class_symbol__)
    def shift(this, xinc, yinc), do: new_point(x(this) + xinc, y(this) + yinc)
    <<objects2>>
  end
#+END_SRC


** Exercise 1: Implement add

I think I'll switch over to doctests instead of separate unit tests.

#+name: objects2
#+BEGIN_SRC elixir
  @doc """
  ## Examples:
      iex> p1 = new_point(3, 7)
      iex> p2 = new_point(8, -3)
      iex> p3 = add(p1, p2)
      iex> x(p3)
      11
      iex> y(p3)
      4
  """
  def add(p1, p2), do: shift(p1, x(p2), y(p2))
#+END_SRC


** Exercise 2: A "new" operator

If I did this exactly like the Clojure version I'd have to call it
like this:

#+BEGIN_SRC ruby
make(&new_point/1, [3, 5])
#+END_SRC

Blerg. I'll make a macro instead.

#+name: objects2
#+BEGIN_SRC elixir
  @doc """
  ## Examples
      iex> p = make(point, [3, 5])
      iex> class_of(p)
      :point
      iex> x(p)
      3
      iex> y(p)
      5
  """
  defmacro make(class, args) do
    {classname,_,_} = class
    constructor = binary_to_atom("new_#{classname}")
    quote do
      unquote(constructor)(unquote_splicing(args))
    end
  end
#+END_SRC

OK, that was kinda cool. Of course, if I were willing to put up with
passing the classname as a symbol rather than as a bareword, I
wouldn't need a macro.

#+name: objects2
#+BEGIN_SRC elixir
  @doc """
  ## Examples
      iex> p = make2(:point, [3, 5])
      iex> class_of(p)
      :point
      iex> x(p)
      3
      iex> y(p)
      5
  """
  def make2(class, args) do
    constructor = :"new_#{class}"
    code = {constructor, [], args}
    {result, _} = Code.eval_quoted(code, binding, delegate_locals_to: __MODULE__)
    result
  end
#+END_SRC

Note the use of =delegate_locals_to: __MODULE__= to enable the
=eval_quoted= to find methods in the current module.

The next three exercises involve comparing triangles and I just can't
get excited about that, so I'm gonna stop here.



* FPOO Chapter 4: Encapsulating methods in the constructor

[boilerplate bypath="fp-oo"]

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export :exports none
  defmodule TestObjects3 do
    use ExUnit.Case
    import FpOoElx.Exercises.Objects3
    doctest FpOoElx.Exercises.Objects3
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir :exports none
  defmodule Objects3 do
    import Dict
    defmacro make(class, args) do
      {classname,_,_} = class
      constructor = binary_to_atom("new_#{classname}")
      quote do
        unquote(constructor)(unquote_splicing(args))
      end
    end
    <<objects3>>
  end
#+END_SRC

Today I slightly refine the nascent OO implementation in
Elixir. Here's the new =point= constructor, with methods contained
within it:

#+BEGIN_SRC elixir
  def new_point(x, y) do
    [
      x: x, 
      y: y, 
      __class_symbol__: :point,
      __methods__: [
        class: &get(&1, :__class_symbol__),
        shift: fn 
                 (this, xinc, yinc) -> new_point(get(this, :x) + xinc, get(this, :y) + yinc)
               end
      ]
    ]
  end  
#+END_SRC

And here's =send_to=, which (slightly) eases sending messages to
objects.

#+name: objects3
#+BEGIN_SRC elixir
  @doc """
  ## Examples
      iex> p = make(point, [3, 5])
      iex> p2 = send_to(p, :shift, [2,4])
      iex> Dict.get(p2, :x)
      5
      iex> Dict.get(p2, :y)
      9 
  """
  def send_to(object, message, args // []) do
    method_table = get(object, :__methods__)
    method       = get(method_table, message)
    apply(method, [object|args])
  end
#+END_SRC


** Exercise 1: x, y, and add

This exercise re-adds =x=, =y=, and =add= methods.

#+name: objects3
#+BEGIN_SRC elixir
  @doc """
  iex> p1 = make(point, [3,5])
  iex> p2 = make(point, [-2,3])
  iex> p3 = send_to(p1, :add, [p2])
  iex> send_to(p3, :x)
  1
  iex> send_to(p3, :y)
  8
  """
  def new_point(x, y) do
    [
      x: x, 
      y: y, 
      __class_symbol__: :point,
      __methods__: [
        class: &get(&1, :__class_symbol__),
        shift: fn 
                 (this, xinc, yinc) -> new_point(get(this, :x) + xinc, get(this, :y) + yinc)
               end,
        x: &get(&1, :x),
        y: &get(&1, :y),
        add: fn (this, other) -> send_to(this, :shift, [send_to(other, :x), send_to(other, :y)]) end
      ]
    ]
  end  
#+END_SRC

This is all quite horrible so far; presumably I'll be cleaning it up
as I progress further in the book.

* FPOO Chapter 5: Classes                                       :fpoo:elixir:

  [boilerplate bypath="fp-oo"]

#+name: tests
#+BEGIN_SRC elixir :noweb strip-export :exports none
  defmodule TestObjects4 do
    use ExUnit.Case
    import FpOoElx.Exercises.Objects4
    doctest FpOoElx.Exercises.Objects4
    <<object_tests4>>
  end  
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir :exports none
  defmodule Objects4 do
    import Dict
    <<objects4>>
  end
#+END_SRC

So far, my tiny object system in Elixir has been stowing all methods
directly in instances. Chapter 5 of FPOO directs me to move instance
methods out into a "class" of some kind.

First off, there's no more =new_point=. In its place, a simple keyword
list defining attributes of the class. The instance variables are no
longer hard-coded in the keyword list. Instead, there is a new
=add_instance_values= callback that plays the role of an initializer
method.

#+BEGIN_SRC elixir
  def point() do 
    [
      __own_symbol__: :point,
      __instance_methods__: [
        class: &get(&1, :__class_symbol__),
        add_instance_values: fn (this, x, y) ->
                                  this |> merge([x: x, y: y])
                             end,
        shift: fn (this, xinc, yinc) -> 
                    make(point, [get(this, :x) + xinc, get(this, :y) + yinc])
               end
      ]
    ]
  end
#+END_SRC

Next up, a new =make= function that can use this style of class definition.

#+BEGIN_SRC elixir
  def make(class, args) do
    allocated   = []
    seeded      = allocated |> merge([__class_symbol__: get(class, :__own_symbol__)])
    constructor = class |> get(:__instance_methods__) |> get(:add_instance_values)
    apply(constructor, [seeded|args])
  end
#+END_SRC

Now for message dispatch.

#+BEGIN_SRC elixir
  def send_to(object, message, args // []) do
    class_name = object |> get(:__class_symbol__) 
    class      = apply(__MODULE__, class_name, [])
    method     = class |> get(:__instance_methods__) |> get(message)
    apply(method, [object|args])
  end
#+END_SRC

I gotta say, I kind of prefer Elixir pipelines for chaining keyword
gets:

#+BEGIN_SRC elixir
class |> get(:__instance_methods__) |> get(message)
#+END_SRC

...to Clojure nested function calls:

#+BEGIN_SRC clj
(let [method (message (:__instance_methods__ class))])
#+END_SRC

Before I go any further, let's see if any of this is working.

#+name: object_tests4
#+BEGIN_SRC elixir
  test "class-based object creation" do
    import Dict
    p = make(point, [23, 42])
    assert(get(p, :x) == 23)
    assert(get(p, :y) == 42)
    p2 = send_to(p, :shift, [2, 3])
    assert(get(p2, :x) == 25)
    assert(get(p2, :y) == 45)
  end
#+END_SRC


*** Exercise 1: apply-message-to

A small refactoring to pull out this helper method:

#+name: objects4
#+BEGIN_SRC elixir
  def apply_message_to(class, object, message, args) do
    method = class |> get(:__instance_methods__) |> get(message)
    apply(method, [object|args])
  end  
#+END_SRC

Now the =make= and =send_to= functions can be refactored to use this new helper method.

#+name: objects4
#+BEGIN_SRC elixir
  def make(class, args) do
    allocated   = []
    seeded      = allocated |> merge([__class_symbol__: get(class, :__own_symbol__)])
    apply_message_to(class, seeded, :add_instance_values, args)
  end
#+END_SRC

#+name: objects4
#+BEGIN_SRC elixir
  def send_to(object, message, args // []) do
    class_name = object |> get(:__class_symbol__) 
    class      = apply(__MODULE__, class_name, [])
    apply_message_to(class, object, message, args)
  end
#+END_SRC


*** Exercise 2: class and class-name

The behavior I want:

#+name: object_tests4
#+BEGIN_SRC elixir
  test "class and class name" do
    p = make(point, [23, 42])
    assert(send_to(p, :class) == point)
    assert(send_to(p, :class_name) == :point)
  end
#+END_SRC

This necessitates a change to the class definition:

#+name: objects4
#+BEGIN_SRC elixir
  def point() do 
    [
      __own_symbol__: :point,
      __instance_methods__: [
        class_name: &get(&1, :__class_symbol__),
        class: fn (_this) -> point end,
        add_instance_values: fn (this, x, y) ->
                                  this |> merge([x: x, y: y])
                             end,
        shift: fn (this, xinc, yinc) -> 
                    make(point, [get(this, :x) + xinc, get(this, :y) + yinc])
               end
      ]
    ]
  end
#+END_SRC


