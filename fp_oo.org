#+TITLE: FPOO in Elixir
#+OPTIONS: num:nil ^:nil toc:nil

* Setup

Let's define a module to keep exercises in.

#+name: exercises_module
#+BEGIN_SRC elixir :tangle lib/fp_oo_elx/exercises.ex :noweb yes
  defmodule FpOoElx.Exercises do
    <<exercises>>
  end
#+END_SRC

And a module to keep tests in.

#+name: tests_module
#+BEGIN_SRC elixir :tangle test/exercises_test.exs :noweb yes
  defmodule ExercisesTest do
    use ExUnit.Case
    import FpOoElx.Exercises
    <<tests>>
  end
#+END_SRC


* Chapter 1


** Re-implementing apply in Elixir                              :fpoo:elixir:
   :PROPERTIES:
   :ID:       o2b:6e62c054-5535-4cd8-8b37-51b176ad4585
   :POST_DATE: [2013-11-16 Sat 17:31]
   :POSTID:   7849
   :BLOG:     virtuouscode
   :CATEGORY: Elixir
   :END:

Elixir already has a perfectly good [[http://elixir-lang.org/docs/stable/Kernel.html#apply/2][=apply=]]. But [[https://leanpub.com/fp-oo][FPOO]] suggests I try
to write my own version, and why not?

#+name: exercises
#+BEGIN_SRC elixir
  def my_apply(func, sequence) do
    code = quote do
      unquote(func).(unquote_splicing(sequence))
    end
    {result, _} = Code.eval_quoted(code)
    result
  end
#+END_SRC

This is considerably more verbose than the Clojure example in the
book, without really seeming to add much expressiveness:

#+BEGIN_SRC clj
  (def my-apply
    (fn [function sequence]
      (eval (cons function sequence))))
#+END_SRC

Perhaps an Elixir-experienced reader can show me a more idiomatic
form. Although I think Elixir metaprogramming is likely always going
to be wordier than Lisp because of a) its less-concise
quoting/unquoting constructs; and b) the fact that the sexp-ish things
that Elixir macros work on under the covers are more complex than
their lisp counterparts. As an example, here's the code-as-data
version of adding two integers:

#+BEGIN_SRC elixir
quote do: 1 + 2
# => {:+, [context: Elixir, import: Kernel], [1, 2]}
#+END_SRC

Whereas the lisp code-as-data representation of =(+ 1 2)= is,
well... =(+ 1 2)=.

Actually, that gives me an idea. Let's see if we can do this by
constructing sexps instead of with quoting and unquoting.

#+name: exercises
#+BEGIN_SRC elixir
  def my_apply2(func, sequence) do
    {result, _} = Code.eval_quoted({{:., [], [func]}, [], sequence})
    result
  end
#+END_SRC

This is a lot shorter. It feels kind of like working with secret
knowledge though. The Elixir sexp representation is so different from
ordinary written code that it's hard to look at code that /constructs/
code in this way and visualize what it's building.

Here are the tests, just to prove this all works.

#+name: tests
#+BEGIN_SRC elixir
  test "my_apply" do
    assert(my_apply(&(&1 + &2), [1,2]) == 3)
  end

  test "my_apply2" do
    assert(my_apply2(&(&1 + &2), [1,2]) == 3)
  end
#+END_SRC

Here I'm using the new [[http://elixir-lang.org/docs/stable/Kernel.SpecialForms.html#&/1][capture operator]], introduced in 0.11.0, to
capture an anonymous function reference to [[http://elixir-lang.org/docs/stable/Kernel.html#%2B/2][=Kernel.+/2=]]:

#+BEGIN_SRC elixir
&(&1 + &2)
#+END_SRC

Believe it or not, this is a lot more concise than the old way. It's
still frustratingly awkward coming from Lisp, Haskell, or pretty much
any other FPL. Or Ruby, for that matter, where we'd probably represent
the function (method) to be applied as simply =:+=. In Clojure, we
take a reference to the =+= function using, wait for it... =+=.

Well, now that I've applied myself (hah!) to this little problem,
let's see how Elixir itself implements =apply=. This is easy, because
the Elixir [[http://elixir-lang.org/docs/stable/Kernel.html#apply/2][API docs]] link directly to the relevant code on
Github. Bless you for that, [[https://github.com/josevalim][Mr. Valim]].

Turns out, Elixir just punts it over to Erlang:

#+BEGIN_SRC elixir
  defmacro apply(fun, args) do
    quote do
      :erlang.apply(unquote(fun), unquote(args))
    end
  end
#+END_SRC

I should have guessed this would be the case.

** FPOO Ch. 1 Exercises in Elixir                       :fpoo:elixir:clojure:
   :PROPERTIES:
   :ID:       o2b:e2da1415-8763-47d5-bc21-26a01da342db
   :POST_DATE: [2013-11-19 Tue 09:00]
   :POSTID:   7857
   :BLOG:     virtuouscode
   :CATEGORY: Elixir
   :END:

*** Exercise 3: add-squares

First up, we have =add-squares=. Let's write a test...

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-3: add-squares" do
    assert(add_squares([1, 2, 5]) == 30)
  end
#+END_SRC

My Elixir version takes a list rather than a variable number of
arguments, because Erlang doesn't do the varargs thing.

As for implementation...

#+name: exercises
#+BEGIN_SRC elixir
  def add_squares([n|ns]), do: n*n + add_squares(ns)
  def add_squares([]), do: 0
#+END_SRC

Elixir is all about recursion and pattern matching.

(Aside: I understand why it's there, but that darn comma after the
method and before the =do:= when writing one-liners gets me every
freakin' time.)

Hmmm... so far FPOO has avoided introducing =defun=, instead defining
functions by creating them anonymously and then assigning them to a
name. I'm suddenly curious how easy this is in Elixir.

#+BEGIN_SRC elixir
  add_squares = fn
                  [n|ns] -> n*n + add_squares(ns)
                  []     -> 0
                end
#+END_SRC

I realized halfway through writing this that it will lead to a compile
error:

#+BEGIN_EXAMPLE


(CompileError) lib/fp_oo_elx/exercises.ex:17: function add_squares/1 un
defined
#+END_EXAMPLE

I remember now. There's no way (that I'm aware of) to refer to an
anonymous function within itself, so we can't do recursive anonymous
functions in Elixir.

(Aside: why is there no =do= after =fn=???)

OK, I guess I'll stick to named functions. I can always take
anonymous-style references to named functions with the capture (=&=)
operator, so hopefully this won't get in the way.

*** Exercise 4: Bizarro-factorial

"Implement a bizarre version of factorial that uses neither iteration
of recursion". Specifically, the instructions say to use =range= and
=apply=.

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-4: bizarro-factorial" do
    assert(bizarro_factorial(5) == 120)
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  def bizarro_factorial(n) do
    (1..n) |> Enum.reduce(&(&1 * &2))
  end
#+END_SRC

This is probably a gratuitous use of the pipeline operator (=|>=),
but I don't care!

Note that FPOO specifies that I use only =range= and =apply=. The
range operator (=..=) is the Elixir equivalent of =range=. On the
other hand, =apply= doesn't really translate well. Sure, Elixir has
it. But Erlang (and thus Elixir) doesn't have the concept of
functions that take arbitrary numbers of arguments, the way =*= in
lisp can yield the product of an arbitrary number of numbers:

#+BEGIN_SRC clj
(* 1 2 3 4 5)
#+END_SRC

Instead, =Kernel.*= is a strictly binary operator. So I have to cheat
and use =Enum.reduce=, which is a recursive function under the covers.

*** Exercise 5: Various sequence functions

I'm going to quickly run through these just so I know what the Elixir
equivalents are. I'll use the =Stream= versions when they exist,
since the Clojure versions demonstrated in the book all operate on
potentially lazy sequences.

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-5: sequence functions" do
    # take
    assert(Enum.take([1,2,3], 2) == [1,2])
    # distinct
    assert(Enum.uniq([1,2,1,3,2]) == [1,2,3])
    # concat
    assert(Stream.concat([u[1,2], [3,4]]) |> Enum.take(4) == [1,2,3,4])
    # repeat
    xs = Stream.repeatedly(fn -> "x" end)
    assert(xs |> Enum.take(3) == ["x", "x", "x"])
    
    # interleave
    # there appears to be no interleave. There's Enum.zip, which only
    # zips two collections, and isn't lazy(?).
  
    # drop
    assert((1..4) |> Enum.drop(2) == [3,4])
  
    # drop-last
    assert((1..4) |> Enum.slice(0..-2) == [1,2,3])
  
    # flatten
    assert(List.flatten([[1,2], [3,4]]) == [1,2,3,4])
  
    # partition
    assert((1..10) |> Enum.partition(&Integer.even?(&1)) == {[2,4,6,8,10], [1,3,5,7,9]})
  
    # every?
    assert([2,4,6] |> Enum.all?(&Integer.even?(&1)) == true)
    assert([1,4,6] |> Enum.all?(&Integer.even?(&1)) == false)
  
    # remove
    assert((1..10) |> Stream.reject(&Integer.even?/1) |> Enum.take(5) == [1,3,5,7,9])
  end
#+END_SRC

These translations were delightfully easy to do; in almost every
case, the Elixir version of the Clojure function either had a) the
same name; or b) the name of the equivalent operation in Ruby
(e.g. =remove= becomes =reject=).

One thing that has stood out as I've worked through these is that the
=Stream= module is a lot more limited than the =Enum= module. And
from my brief experimentation, =Enum= functions are /not/ lazy. So,
for instance, this expression will never return, even though we are
only trying to take the first three unique items from the stream:

#+BEGIN_SRC elixir
  [1,2,3,4,5] |> Stream.cycle |> Enum.uniq |> Stream.take(3)
#+END_SRC

Evidently =Enum.uniq= tries to convert the stream into a fixed
collection, rather than returning a filtered stream in this case.

Since FPOO is already talking about laziness a lot (and all sequences
seem to be treated as lazy and potentially infinite in Clojure), this
may become a problem for later examples. More broadly, this doesn't
bode well for writing truly generic functions that can process any
kind of collection, including streams, in Elixir. However, Elixir is
still very young, and I suspect that the =Stream= library will grow with
time.




*** Exercise 6: prefix-of?

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-6: prefix-of?" do
    assert(prefix_of?([1,2], [1,2,3,4]) == true)
    assert(prefix_of?([2,3], [1,2,3,4]) == false)
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir
  def prefix_of?(candidate, sequence) do
    import Enum
    size   = count(candidate)
    subseq = sequence |> take(size)
    candidate == subseq
  end
#+END_SRC

*** Exercise 7: tails

#+name: tests
#+BEGIN_SRC elixir
  test "1.18-7: tails" do
    assert([1,2,3,4] |> tails == [[1,2,3,4], [2,3,4], [3,4], [4], []])
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir  
  def tails([x|xs] = sequence), do: [sequence|tails(xs)]
  def tails([]), do: [[]]
#+END_SRC

Marick says "my solution is very much in the functional style", and
then goes on to offer some hints having to do with using Clojure's
=range= and =map=. I'm going to go out on a limb and say that the
solution I came up with first is /even more/ in the functional style,
since it relies entirely on destructuring and recursion and doesn't
require any library calls at all.

Just for fun, here's a more direct translation of [[https://github.com/marick/fp-oo/blob/master/solutions/just-enough-clojure.clj#L113][Marick's solution]]:

#+name: tests
#+BEGIN_SRC elixir :exports none
  test "1.18-7: tails2" do
    assert([1,2,3,4] |> tails2 == [[1,2,3,4], [2,3,4], [3,4], [4], []])
  end
#+END_SRC

#+name: exercises
#+BEGIN_SRC elixir  
  def tails2(seq) do
    import Enum
    0..count(seq) |> map(&drop(seq, &1))
  end
#+END_SRC

His solution is actually a bit more involved than this, because it
involves mapping over /both/ the range =0..count(seq)= and a repeated
list of the sequence itself. I'm guessing this is because he hasn't
yet explicitly introduced lambdas apart from the top-level function
definitions.

#+BEGIN_SRC clj
  (def tails
    (fn [seq]
      (map drop
           (range (inc (count seq)))
           (repeat (inc (count seq)) seq))))
#+END_SRC

If nothing else, this demonstrates that Clojure's =map= can map over
multiple sequences in parallel, which is kinda cool.










